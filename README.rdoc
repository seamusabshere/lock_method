= lock_method

It's like <tt>alias_method</tt>, but it's <tt>lock_method</tt>!

== Example

    require 'lock_method'
    class Blog
      attr_accessor :url
      
      def get_latest_entries
        sleep 5
      end
      lock_method :get_latest_entries

      # used by lock_method to differentiate between instances
      def hash
        url.hash
      end
    end

Then you can do

    my_blog.get_latest_entries => it will start...
    my_blog.get_latest_entries => this will raise LockMethod::Locked if you try to run it before the other call finishes

Just in case, you can clear them

    my_blog.clear_method_lock :get_latest_entries

== Real-world usage

In production use at {carbon.brighterplanet.com}[http://carbon.brighterplanet.com], the Brighter Planet emission estimate web service.

== Ignores arguments when locking a method

lock_method ignores arguments when locking. So if you call Foo.bar(:a), calls to Foo.bar(:b) will be locked until the first call finishes.

Maybe future versions will support this.

== Defining #hash

If you want to lock instance methods, you should define <tt>#hash</tt> on those instances.

You should follow Ruby convention and have <tt>#hash</tt> return a <tt>Fixnum</tt>.

Ideally, you should try to make a <tt>String</tt> or a <tt>Hash</tt> and call the standard <tt>#hash</tt> on that.

Note: this is NOT the same thing as <tt>#to_hash</tt>! That returns a <tt>Hash</tt>... but what we want is an integer "hash code."

== Configuration (and supported cache clients)

The default is to use filesystem lockfiles, usually in <tt>/tmp/lock_method/*</tt>.

If you want to share locks among various machines, you can use a Memcached or Redis client:

    LockMethod.config.storage = Memcached.new '127.0.0.1:11211'

or

    LockMethod.config.storage = Redis.new

or this might even work...

    LockMethod.config.storage = Rails.cache

See Config for the full list of supported caches.

== Copyright

Copyright 2011 Seamus Abshere
